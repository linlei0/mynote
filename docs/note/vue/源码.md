# vue2源码

## 在学习之前先了解什么是运行时，编译时
**runtime(运行时)：当前程序运行过程中，保存的状态和数据**
    举个简单的例子,当我们实例化Vue的时候就创建了一个内存对象,我们可以通过mounted来改变data中的数据
```javascript
    new Vue({
        data: {
            return {a:1}
        }
        mounted() {
            this.a = 2
        }
        ...
    })
```
**runtime+compiler(编译时)：也和运行时一样，只不过多了一个解析vue模板的过程**
compiler：在线编译模板
    如下所示是一个简单的模板解析后的js代码
```javascript
<div><p>{{ name }}</p></div>
with(this) {
    return _c('div',[
        _c('p',[
            _v(_s(name))
        ])
    ])
}
```
## 目录
- **1./compiler目录编译模板**

    作用：将.vue-->打包编译 (词法分析，语法分析，构建AST,转义js) -->输出 render()
    然后使用正则匹配词法模板，缺点是效率很慢 
- 2.core目录是vue.js的核心
    /component -->keep-alive
    global-api 全局api .use .mixin .extend
    instance 生命周期，时间绑定处理
    observer 双向数据绑定的逻辑

    utils 常用工具集
    vdom 虚拟dom snabbdom
- 3./entries 生产打包的入口
- 4./platform 针对核心模块的平台模块
- 5.platform 目录下在那时只有web目录(在最新的开发目录中已经有weex目录)。web目录下对应的/compiler，/runtime，
    /server，/util目录
- 6. /server目录是处理服务端渲染
- 7. /sfc目录处理单文件 .vue
8 /shared 目录提供全局用到的工具函数
# 整体架构

# vue的整体流程

# vue运行时的优化

双向数据绑定
Object.defineProperty 
不能监听新增的key
get： 数据获取渲染视图

```javascript
let obj = {b:1}
Object.defineProperty(obj,'b',{
    get: function(key) {
        console.log('get val',key)
    },
    set: function(newVal) {
        console.log('set val',key)
    }
})
```
数组的变更会导致频繁的移动位置,如下所示
```javascript
function observer(data) {
    Object.keys(data).forEach(function(key){
        defineReactive(data,key,data[key])
    })
}
function defineReactive(data,key,value) {
    Object.defineProperty(data,key,{
    get: function(key) {
        console.log('get val',value)
        return value
    },
    set: function(newVal) {
        console.log('set val',newVal)
        newVal = value
    }
})
}
const  arr = [1,2,3,4]
observer(arr)
arr.unshift(5)
```
如果触发了数据的修改和数据的获取，都可以监听到
先触发observer

Observer

watcher(衔接数据和指令的过程)
 (一个指令对应一个watcher，实际是一个模板对应一个watcher)

 ![result1](/vue/双向绑定.png?200*300)
 流程说明：当我们代码中写入基本的vue肯定会有data，模板dom                                                                                                                                                                                                                                   
 此时模板会生成一个指令也就是Directive，会对应一个watcher，
 而data则会实现数据得监听也就是Observer，当watcher中使用data中的数据时会去找到Observer中的get，
 同时会将watcher添加到dep中留存，当data中的数据变更时则触发Observer中的set，在dep中找到留存的watcher，watcher通知指令
 更新视图



 ## domdiff

 - 1.虚拟dom是什么?

  主要就是一个对象，来描述dom节点，jsx react 也就是createElement方法在vue的h方法
  
  如下： 我们有了我们的h方法并传其type，props，...children
```js
<div id="wrapper">
    <span id="text" style="color: red">hello</span>
    "zf"
</div> 
  h('div',{id: 'wrapper'},h('span',{id: 'text',style: {color: 'red'}},'hello'),'zf')

 const domObj = {
     type: 'div',
     props: {
        id: 'wrapper',
    },
    children: [
        {
            type: 'span', props: {id: 'text', style: {color: 'red'}
        }, 
        children: [
            {
                type: '',props: '',
                children: [],text: 'hello'}
                ]
        },
        { type: '',props: '', children: [], text: 'zf' }
    ]
 }
```
 - 2.如何创建虚拟dom？
 ***本例所有代码均基于webapck，请自行搭建webapck环境***
 代码如下，我们在src下创建vdom文件夹，然后创建h.js(暴露出h方法)和vndoe.js(返回虚拟节点对象)
 **h.js**
```js
 import { vnode } from './vnode'
 /**
  * 
  * @param {*} type 类型
  * @param {*} props 属性
  * @param  {...any} children 子节点
  */

 export default function createElement(type,props={},...children) {
    let key
    if(props.key) {
        key = props.key
        delete props.key
    }
    // 处理所有的子节点，如果子节点是string则表明是dom节点的文字了需要转换成虚拟节点，
    children = children.map(child => {
        if(typeof child === 'string') {
            return vnode(undefined, undefined, undefined,undefined,child)
        } else {
            return child
        }
    })

    return vnode(type,props,key,children)
}
```
**vnode.js**
```js
/**
 * 
 * @param {*} type 
 * @param {*} props 
 * @param {*} key 
 * @param {*} children 
 * @param {*} text 
 */
export function vnode(type,props,key,children,text) {
    return {
        type,
        props,
        key,
        children,
        text
    }
}
```
以上方法实现之后在vdom下创建index.js文件
**vdom/index.js**
```js
import h from './h'
// import { render } from './patch'
export {
    h,
    // render
}
```
使用
**src/index.js**
```js
import { h } from './vdom'
const vnode = h(
    'div',
    {id: 'wrapper', style: {color: 'red'}},
    h(
        'span',
        {id: 'text',style: {color: 'red'}},'hello',
        h('i', {id: 'iiii',style: {color: 'green'}}, '我是i标签')
        ),
    'zf'
)
// const app = document.getElementById('app')
console.log(vnode)
```
打印结果如下：
```json
{
    "type":"div",
    "props":{
        "id":"wrapper",
        "style":{
            "color":"red"
        }
    },
    "children":[
        {
            "type":"span",
            "props":{
                "id":"text",
                "style":{
                    "color":"red"
                }
            },
            "children":[
                {
                    "text":"hello"
                },
                {
                    "type":"i",
                    "props":{
                        "id":"iiii",
                        "style":{
                            "color":"green"
                        }
                    },
                    "children":[
                        {
                            "text":"我是i标签"
                        }
                    ]
                }
            ]
        },
        {
            "text":"zf"
        }
    ]
}
```
说明：通过打印结果我们可以发现所谓的虚拟dom其实就一个对象，这个对象上type，props，children属性，
核心方法createElement也就是h方法会把我们的每一个最终会转换成vnode对象，这个对象就是我们所需要的虚拟对象了。

 -3.虚拟dom如何渲染成真实dom？
 我们先创建patch.js
 ```js
/**
 * 
 * @param {*} vnode 用户虚拟节点
 * @param {*} container 渲染到那个节点上
 */
export function render(vnode,container) {
    // console.log(vnode,container)
    const ele = createDomElementFrom(vnode)
    container.appendChild(ele)

}
//通过虚拟丶对象创建真实的dom
function createDomElementFrom(vnode) {
    let {type,key,props,children,text} = vnode
    // 表明传递的是一个标签，否则是一个文本
    if(type) {
        vnode.domElement = document.createElement(type) 
        updateProperties(vnode)
        // 递归渲染子的虚拟节点
        children.forEach(childrenVnode=>render(childrenVnode,vnode.domElement))
    } else {
        vnode.domElement = document.createTextNode(text) 
    }
    return vnode.domElement
}
// 后续比对的时候，会根据老的属性和新的属性重新更新节点
function updateProperties(newVnode,oldProps = {}) {
    let domElement = newVnode.domElement // 真实的dom
    let newProps = newVnode.props // 当前虚拟节点中的属性

    // 如果老的节点有，新的节点没有，说明被移除了
    for(let oldPropsName in oldProps) {
        if(!newProps[oldPropsName]) {
            delete domElement[oldPropsName];
        }
    }
    //  如果新的里面有style，老的里面也有style，style可能不一样
    const newStyleObj = newProps.style || {}
    const oldStyleObj = oldProps.style || {}

    for(let s in oldStyleObj) {
        if(!newStyleObj[s]) {
            domElement.style[s] = ''
        }
    }
    // 如果老的节点没有，新节点有，说明是新增
    for(let newPropsName in newProps) {
        if(newPropsName==='style') {
            const styleObj = newProps[newPropsName]
            for(let key in styleObj) {
                domElement.style[key] = styleObj[key]
            }
        } else {
            domElement[newPropsName] = newProps[newPropsName]
        }
    }
}
 ```
 使用
 ```js
 import { h, render } from './vdom'
const vnode = h(
    'div',
    {id: 'wrapper', style: {color: 'red'}},
    h(
        'span',
        {id: 'text',style: {color: 'red'}},'hello',
        h('i', {id: 'iiii',style: {color: 'green'}}, '我是i标签')
        ),
    'zf'
)
const app = document.getElementById('app')
render(vnode,app)
 ```
说明：createDomElementFrom方法用来创建真实的dom最后挂载在app上，首先我们需要判断type属性如果存在则表明是一个标签那么就是用
document.createElement，如果不存在则说明是文本document.createTextNode，然后使用递归创建全部的节点**children.forEach(childrenVnode=>render(childrenVnode,vnode.domElement))**此时我们的dom就全部创建完成了，然后我们需要添加他的属性，这个时候我们就要考虑到新属性和旧属性的问题了，如果老的节点有，新的节点没有，说明被移除了，如果老的节点没有，新节点有，说明是新增，以及style的问题如果新的里面有style，老的里面也有style，style可能不一样，到这里我们的真实dom就创建完成了。

 - 4.虚拟dom如何patch？
    1.类型不同,如下src/index.js我们创建一个newVode虚拟dom，并创建patch.js此时我们只需要将dom更换即可
```js
// src/index.js
import { h, render, patch} from './vdom'
const oldVnode = h(
    'div',
    {id: 'wrapper', style: {color: 'red'}},
    h(
        'span',
        {id: 'text',style: {color: 'red'}},'hello',
        h('i', {id: 'iiii',style: {color: 'green'}}, '我是i标签')
        ),
    'zf'
)
const app = document.getElementById('app')
render(oldVnode,app)
a
const newVode = h('a',{id: 'a', style: {color: 'blue','font-size': '20px'}}, '更新的dom')

setTimeout(() => {
    patch(oldVnode, newVode)
}, 2000)
```
```js
// vdom/patch.js
...
export function patch(oldVnode, newVnode) {
    console.log(oldVnode, newVnode)
    // 如果老节点的类型和新节点类型不一样直接替换全局
    if(oldVnode.type!==newVnode.type) {
        return oldVnode.domElement.parentNode.replaceChild(createDomElementFrom(newVnode), oldVnode.domElement)
    }
}
```
    2.类型相同，文本不同，我们只需要把文本修改即可
   ```js
// vdom/patch.js
...
export function patch(oldVnode, newVnode) {
    console.log(oldVnode, newVnode)
    // 如果老节点的类型和新节点类型不一样直接替换全局
    if(oldVnode.type!==newVnode.type) {
        return oldVnode.domElement.parentNode.replaceChild(createDomElementFrom(newVnode), oldVnode.domElement)
    }
    // 类型相同，文本不同
    if(oldVnode.text) {
        return oldVnode.domElement.textContent = newVnode.text
    }
}
``` 
    3.类型一样并且是标签，需要根据新节点的属性，更新老节点的属性,我们不需要创建新的dom了，只需要在原有的dom上更改即可
```js
export function patch(oldVnode, newVnode) {
    ...
    // 类型一样并且是标签，需要根据新节点的属性，更新老节点的属性
    let domElement = newVnode.domElement = oldVnode.domElement

    updateProperties(newVnode,oldVnode.props)

}
```
    4.类型一样，子节点有更新
    (1).老的有节点，新的有节点
    (2).老的有节点，新的有没节点
    (3).老的没节点，新的有节点

```js
export function patch(oldVnode, newVnode) {
    ...
    if(oldChildren.length && newchildren.length) {
        // 真正的diff 
        // 常见的dom操作进行优化
        // 1.前后追加
        // 2.正序倒序
        updateChildren(domElement,oldChildren,newchildren)
    } else if(oldChildren.length && !newchildren.length) {
        domElement.innerHTML = ''
    } else if(!oldChildren.length && newchildren.length) {
        for(let i=0; i<newchildren.length; i++) {
            domElement.appendChild(createDomElementFrom(newchildren[i]))
        }
    }
}
// 在头尾创建两个指针
function updateChildren(parent,oldChildren,newChildren) {
    let oldStartIndex = 0
    let oldStartVnode = oldChildren[0]
    let oldEndIndex = oldChildren.length - 1
    let oldEndNode = oldChildren[oldEndIndex]
    let newStartIndex = 0
    let newStartVnode = newChildren[0]
    let newEndIndex = newChildren.length - 1
    let newEndNode = newChildren[newEndIndex]
    // 前追加
    // 找到相同的
    while(oldStartIndex<=oldEndIndex && newStartIndex <= newEndIndex) {
        if(isSameVnode(oldStartVnode,newStartVnode)) {
            patch(oldStartVnode,newStartVnode)
            oldStartVnode = oldChildren[++oldStartIndex]
            newStartVnode = newChildren[++newStartIndex]
        }
    }
    // 相同之后的只需要添加就行
    for(let i= newStartIndex;i<=newEndIndex;i++) {
        let beforeElement = newChildren[newStartIndex+1] == null ? null : newChildren[newStartIndex+1].domElement
        parent.insertBefore(createDomElementFrom(newChildren[i]),beforeElement)
        // parent.appendChild()
    }
}
```
 - 5.虚拟dom的优势？
 - 6.vue中的key有什么作用？
给每个节点做唯一标识，当我们更新patch包时可以通过key找到dom节点，然后修改patch中的需要修改的地方
 - 7.vue中diff算法的实现？
