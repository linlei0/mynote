(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{452:function(t,e,a){"use strict";a.r(e);var s=a(65),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[t._v("#")]),t._v(" React-fiber")]),t._v(" "),a("h2",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),a("ul",[a("li",[t._v("react 在组件渲染的时候，从 setState 开始到渲染完成整个过程是同步的。如果需要渲染的组件比较庞大，js 执行会占据主线程，会导致页面响应度变差，使得 react 在动画，手势等应用中效果比较差。")]),t._v(" "),a("li",[t._v("页面卡顿：Stack 。父组件调用子组件，可以类比为函数的递归；对于特别庞大的 vDOM 树来说，reconciliation 过程会很长，超过 16ms，在这期间，主线程是被 js 占用的，因此任何交互，布局，渲染都会停止，给用户造成页面被卡住的感觉。")])]),t._v(" "),a("h2",{attrs:{id:"实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),a("p",[t._v("旧版本 React 通过递归的方式进行渲染，使用的是 JS 引擎自身的函数调用栈，他会一直执行到栈空为止。使用的是 JS 引擎自身的函数调用栈，他会一直执行到栈空为止。而 Fiber 实现了自己的组件调用栈，它以链表的形式组件树，可以灵活的暂停，继续和丢弃执行的任务。实现方式是使用了浏览器的 requestldleCallback 的这个 API。Fiber 其实指的是一种数据结构，他可以用一个纯 JS 对象来表示：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" fiber "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  stateNode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  child"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  sibling"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[a("p",[t._v("react 内部转运分三层：")]),t._v(" "),a("ul",[a("li",[t._v("Vitrual DOM 描述页面长什么样")]),t._v(" "),a("li",[t._v("Reconciler 层，负责调用组件生命周期方法，进行 DOM 方法")]),t._v(" "),a("li",[t._v("render 层，渲染出相应的页面")])])]),t._v(" "),a("li",[a("p",[t._v("为了实现不卡顿，就需要有一个调度器（Scheduler）来进行任务分配。优先级高的任务可以打断优先级低的任务的执行，从而更快生效。任务的优先级有 6 种：")]),t._v(" "),a("ul",[a("li",[t._v("synchronous，与之前的 Stack 操作一样同步执行")]),t._v(" "),a("li",[t._v("task，在 next Tick 之前执行")]),t._v(" "),a("li",[t._v("high，在不久的将来立即执行")]),t._v(" "),a("li",[t._v("low，稍微延迟执行也没关系")]),t._v(" "),a("li",[t._v("offscreen，下一次 render 时或 scroll 时才执行")])])]),t._v(" "),a("li",[a("p",[t._v("fiber Reconciler（react）执行阶段：")]),t._v(" "),a("ul",[a("li",[t._v("阶段一，生成 Fiber 数，得出需要更新的节点信息。这一步是一个渐进的过程，可以被打断")]),t._v(" "),a("li",[t._v("阶段二，将需要更新的节点，一次过批量更新，这个过程不能被打断")])])]),t._v(" "),a("li",[a("p",[t._v("Fiber Reconciler 在阶段一进行 Diff 计算的时候，会基于 Vitual DOM 树生成一颗 Fiber 树，他的本质是链表")])]),t._v(" "),a("li",[a("p",[t._v("从 Stack Reconciler 到 Fiber Reconciler，源码层面其实就做了一件事递归改循环")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);