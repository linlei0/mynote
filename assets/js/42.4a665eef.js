(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{423:function(s,v,t){"use strict";t.r(v);var _=t(46),a=Object(_.a)({},(function(){var s=this,v=s.$createElement,t=s._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"重绘和重排"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重绘和重排"}},[s._v("#")]),s._v(" 重绘和重排")]),s._v(" "),t("h2",{attrs:{id:"什么是重绘和重排"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是重绘和重排"}},[s._v("#")]),s._v(" 什么是重绘和重排?")]),s._v(" "),t("p",[s._v("当我们改变一个元素的尺寸和位置时候，会重新进行样式计算（computed style）布局（layout）绘制（paint）以及后面的所有流程，这种行为称为重排。\n当改变了某个元素的颜色属性时不会重新触发布局，但还是会触发样式的计算和绘制，这就是重绘。\n我们可以发现重绘和重排都会占用主进程，还有 js 也会运行在这个主线程上，所以就会出现抢占执行时间的问题，如果你写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作。\n触发的一些因素")]),s._v(" "),t("ol",[t("li",[s._v("页面首次进入的渲染")]),s._v(" "),t("li",[s._v("浏览器 resize")]),s._v(" "),t("li",[s._v("元素位置和和尺寸发生改变")]),s._v(" "),t("li",[s._v("可见元素的增删")]),s._v(" "),t("li",[s._v("内容发生改变")]),s._v(" "),t("li",[s._v("字体的 font 改变")]),s._v(" "),t("li",[s._v("css 伪类激活")]),s._v(" "),t("li",[s._v("......")])]),s._v(" "),t("h2",{attrs:{id:"如何优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何优化"}},[s._v("#")]),s._v(" 如何优化？")]),s._v(" "),t("p",[s._v("我们知道当前以每秒 60 帧的刷新率时才不会让用户感觉到卡顿，如果在运行动画时还有大量的 js 任务需要执行，因为布局，绘制和 js 都在主线程运行的，当在一帧的时间内布局和绘制结束后，还有剩余时间 js 就会拿到主线程的使用权，如果 js 执行时间过长，就会导致下一帧开始时 js 没有及时归还主线程，导致下一帧动画没有按时渲染，就会出现页面卡顿。")]),s._v(" "),t("h3",{attrs:{id:"第一种优化方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一种优化方式"}},[s._v("#")]),s._v(" 第一种优化方式：")]),s._v(" "),t("p",[s._v("requestAnimationFrame，他会在每一帧被调用，通过 api 的回调，可以把 js 运行任务分成一些更小的任务块，在每一帧事件用完前暂停 js 执行归还主线程，这样的话在下一帧开始时，主线程就可以按时执行布局和绘制。")]),s._v(" "),t("h3",{attrs:{id:"第二种优化方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二种优化方式"}},[s._v("#")]),s._v(" 第二种优化方式：")]),s._v(" "),t("p",[s._v("栅格化的整个流程不占用主线程，只在合成器线程和栅格线程中运行，这就意味着它无需和 js 抢占主线程。如果反复的进行重绘和重排可能会导致掉帧，这是因为有可能 js 执行阻塞了主进程，而 css 中有个动画属性 transfrom，通过该属性实现的动画不会经过布局和绘制，而是直接运行在合成器线程和栅格线程，所以不会受到主线程中 js 执行的影响。更重要的是通过 transform 是实现的动画由于不需要经过布局绘制样式计算等操作，所以节省了很多运算事件（方便实现负责的动画）。\n避免重绘重排的具体方案")]),s._v(" "),t("p",[t("strong",[s._v("CSS 优化")])]),s._v(" "),t("ul",[t("li",[s._v("使用 transform 替代 top 等位移")]),s._v(" "),t("li",[s._v("使用 visibility 替换 display：none")]),s._v(" "),t("li",[s._v("避免使用 table 布局")]),s._v(" "),t("li",[s._v("尽量在 dom 树的最末端改变 class")]),s._v(" "),t("li",[s._v("避免设置多层内联样式，尽量层级扁平")]),s._v(" "),t("li",[s._v("将动画效果应用到 position 属性为 absolute 或 fixed 的元素上")]),s._v(" "),t("li",[s._v("避免使用 css 表达式")]),s._v(" "),t("li",[s._v("将频繁重绘或者回流的节点设置为图层，比如 video，iframe")]),s._v(" "),t("li",[s._v("css 硬件加速（GPU 加速）。可以是 transform：translateZ(0),opacity,filters,will-change,will-change 提前告诉浏览器元素发生什么变化")])]),s._v(" "),t("p",[t("strong",[s._v("JS 优化")])]),s._v(" "),t("ul",[t("li",[s._v("避免频繁操作样式，合并操作")]),s._v(" "),t("li",[s._v("避免频繁操作 dom，合并操作")]),s._v(" "),t("li",[s._v("防抖节流控制频率")]),s._v(" "),t("li",[s._v("避免频繁的读取会引发回流/重绘的属性，比如上面的 C ，O，S 属性")]),s._v(" "),t("li",[s._v("对具有复杂动画的元素使用绝地定位")])])])}),[],!1,null,null,null);v.default=a.exports}}]);